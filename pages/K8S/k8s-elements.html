<!DOCTYPE html>
<html><head>
<title data-folder-path="/K8S">k8s-elements</title>
<link href=" ../../static/style.css" rel="stylesheet"/>
<link href="../../prism/prism.css" rel="stylesheet"/>
</head>
<body class="body">
<div class="page-folder-header-div">
<h1 class="pagetitle" data-folder-path="K8S">k8s-elements</h1>
<a href="./../..">
<svg fill="none" height="30" stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="30" xmlns="http://www.w3.org/2000/svg">
<path d="M3 11L12 4L21 11"></path>
<path d="M5 10V20H19V10"></path>
<path d="M10 20V14H14V20"></path>
</svg>
</a>
</div>
<!-- Sidebar -->
<div class="sidbear-enclosure-open" id="sidbear-enclosure-open-k8s-elements">
<button class="sidbear-enclosure-button-open" id="sidbear-enclosure-button-k8s-elements" onclick="toggle_sidebar()" type="button">
<svg fill="white" height="30" viewBox="0 0 100 80" width="30" xmlns="http://www.w3.org/2000/svg">
<rect height="10" width="100"></rect>
<rect height="10" width="100" y="30"></rect>
<rect height="10" width="100" y="60"></rect>
</svg>
</button>
<div class="sidebar-mainbox-open" id="sidebar-mainbox-k8s-elements">
<div class="sidebar-subbox-open" id="sidebar-subbox-1" onclick=" append_foldable_content()">
<svg fill="none" height="30" stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="30" xmlns="http://www.w3.org/2000/svg">
<circle cx="12" cy="12" r="10"></circle>
<line x1="12" x2="12" y1="8" y2="16"></line>
<line x1="8" x2="16" y1="12" y2="12"></line>
</svg>
</div>
<div class="sidebar-subbox-open" id="sidebar-subbox-2">
<svg fill="none" height="30" stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="30" xmlns="http://www.w3.org/2000/svg">
<circle cx="12" cy="12" r="10"></circle>
<path d="M9.09 9C9.32591 8.33109 9.78918 7.76807 10.4 7.41421C11.0108 7.06036 11.7266 6.93913 12.4152 7.07107C13.1038 7.20302 13.7206 7.57857 14.162 8.12132C14.6034 8.66407 14.8397 9.33984 14.83 10.03C14.83 12 12.5 12.5 12.5 14"></path>
<circle cx="12" cy="17" r="1"></circle>
</svg>
</div>
<div class="sidebar-subbox-open" id="sidebar-subbox-3">
<svg fill="none" height="30" stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="30" xmlns="http://www.w3.org/2000/svg">
<circle cx="12" cy="12" r="10"></circle>
<path d="M9.09 9C9.32591 8.33109 9.78918 7.76807 10.4 7.41421C11.0108 7.06036 11.7266 6.93913 12.4152 7.07107C13.1038 7.20302 13.7206 7.57857 14.162 8.12132C14.6034 8.66407 14.8397 9.33984 14.83 10.03C14.83 12 12.5 12.5 12.5 14"></path>
<circle cx="12" cy="17" r="1"></circle>
</svg>
</div>
</div>
</div>
<script src="../../prism/prism.js"></script>
<script src="../../static/script.js"></script>

<!--## k8s-manifest #################################################################################################################-->
<div class="foldable-container" id="foldcontainer-k8s-manifest">
<h2 class="foldable-title" id="foldable-title-k8s-manifest">k8s-manifest</h2>
<button class="foldable-content-unfoldbutton" id="foldable-content-unfoldbutton-newchapter" onclick="toggleFoldableContent('k8s-manifest')" type="button">
<svg class="arrow-icon" fill="currentColor" height="16" viewBox="0 0 24 24" width="16" xmlns="http://www.w3.org/2000/svg">
<path d="M7 10l5 5 5-5H7z"></path>
</svg>
</button>
<button class="foldable-content-edittoggle" onclick="fetchEditableContent('k8s-elements','editable-paragraph-k8s-manifest', 'foldable-content-penButton-k8s-manifest')" type="button">
<svg class="wrench-icon" fill="currentColor" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M22.7 19.3l-4.1-4.1c.6-1.1.9-2.3.9-3.5 0-3.9-3.1-7-7-7-1.3 0-2.5.3-3.5.9l3.3 3.3-4 4-3.3-3.3C4.3 10.5 4 11.7 4 13c0 3.9 3.1 7 7 7 1.3 0 2.5-.3 3.5-.9l4.1 4.1c.4.4 1 .4 1.4 0l2.7-2.7c.4-.4.4-1 0-1.4z"></path>
</svg>
</button>
<button class="create-subdiv" id="create-subdiv-k8s-manifest" onclick="add_subdiv('editable-paragraph-k8s-manifest')" type='*button"'>
<svg class="add-tag-icon" fill="none" height="22" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
<!-- < and > symbols -->
<path d="M6 8l-4 4 4 4"></path> <!-- Left angle bracket -->
<path d="M18 8l4 4-4 4"></path> <!-- Right angle bracket -->
<!-- Plus sign in center -->
<path d="M12 10v4"></path>
<path d="M10 12h4"></path>
</svg>
</button>
<div class="foldable-content folded" id="foldable-content-k8s-manifest">
<button class="foldable-content-penButton-hidden" id="foldable-content-penButton-k8s-manifest" onclick="save_editable_content('k8s-elements','editable-paragraph-k8s-manifest', 'page-folder')" type="button">
<svg fill="none" height="30" stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="30" xmlns="http://www.w3.org/2000/svg">
<path d="M12 20h9"></path>
<path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4 12.5-12.5z"></path>
</svg>
</button>
<div class="editable-paragraph" contenteditable="false" id="editable-paragraph-k8s-manifest"><html><head></head><body><pre># manifests


<h2>Kubernetes Manifests </h2>

<h3>What is a Kubernetes manifest file?</h3>

Kubernetes manifest files are YAML or JSON files that describe objects in your cluster.
They’re the primary way to manage your objects as they let you version configurations
alongside your code, then declaratively apply them to your cluster.

Manifests are usually written in YAML, but you can use raw JSON as an alternative.
However, YAML is more readable and supports features such as YAML comments that
are missing from JSON. This makes it better suited to Kubernetes manifests, as files are
often complex and collaboratively developed by multiple team members.

<h3>Example of a Pod manifest</h3>

For example, the following basic manifest describes a Pod called <i>nginx</i>that runs
a container using the nginx:latest image:

<pre><code class="lang-yaml">
apiVersion: apps/v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>

This manifest makes it clear that your cluster has a Pod called nginx with a container that runs
the nginx:latest image. You can use Kubectl to consistently create the Pod from its manifest
in any Kubernetes cluster, without having to remember the syntax of imperative commands
like <b>kubectl run</b>:

<pre><code class="lang-yaml">

# Using an imperative command
$ kubectl run nginx --image nginx:latest

# Declaratively applying a manifest file
$ kubectl apply -f pod.yaml

</code></pre>

This example demonstrates the difference between imperative and declarative configuration.
In the imperative example, you must use specific commands to instruct Kubernetes how to complete the
Pod creation operation. When you use declarative manifest files, Kubernetes reconciles the file’s content

to your cluster’s existing state, then automatically applies any required actions so your cluster reaches
the new desired state.

Manifests are usually written in YAML—as in the example above–but you can use raw JSON as an alternative.
However, YAML is more readable and supports features such as YAML comments that are missing from JSON.
This makes it better suited to Kubernetes manifests, as files are often complex and collaboratively developed
by multiple team members.

<h3>manifests vs. deployments ?</h3>

<i>Manifests</i> are the files that <i>describe what will be deployed</i> in a Kubernetes cluster. Your actual
<b>deployments</b> are <b>created by applying your</b> <i>manifest</i> files to your cluster, typically
using Kubectl or a package manager like Helm.
Note that <i>manifests</i> don’t do anything on their own. They’re just static configuration files that define the
desired state of your Kubernetes objects. Once you’ve applied them to a cluster, then the objects described
by the <i>manifests</i> will exist within the cluster, in the state defined by the <i>manifest</i>.

<h4>How to create Kubernetes manifest files ?</h4>
The basic process of creating a Kubernetes manifest file is the same for all supported object types.
You must create a new YAML file, write your manifest, and then use Kubectl to apply it to your cluster.

<h4>Key components of Kubernetes manifest fields</h4>:

  - <b>apiVersion</b>: This states the Kubernetes API that the object type you’re creating belongs to.
    Top-level objects such as Pods currently belong to the v1 API, whereas other built-ins are scoped
    to more specific APIs: Deployments live in apps/v1, for example. Custom Resource Definitions (CRDs)
    define their own API versions that let you reference the objects they provide.

  - <b>kind</b>: This is the type of object that you’re defining, such as Pod or Deployment.

  - <b>metadata</b>: This field contains essential information about the object, including its name
     and namespace.(more details below)

  - <b>spec</b>:  Strictly speaking, this isn’t a required field, but it is used by most of the object types that
    are built into Kubernetes. This is where you’ll typically define the properties of your object—such as the
    container image used by a Pod or the number of replicas to run in a ReplicaSet.

You can see all these fields in the sample manifest from above:

<pre><code class="lang-yaml">
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>

<h4>Manifest metadata</h4>
The metadata section is used to define your object’s identity and attach any relevant organizational data to it.
It includes the following major fields:

  - <b>name</b> — This is the only required metadata field. It’s the name your object will be assigned in Kubernetes.

  - <b>namespace</b> — When set, this references a Kubernetes namespace that the object will be created within.
    The namespace must already exist in your    cluster. When this field’s omitted, the default namespace is used.

  - <b>labels and annotations</b> — Labels and annotations let you add your own metadata to your objects. Labels
    are intended for information that identifies an object (such as the app or team it belongs to), while annotations
    store arbitrary values like the time the object was created or the system that it’s being managed by.

Although metadata doesn’t directly affect how Kubernetes configures your objects, labels are the primary way
for objects to select each other. It’s therefore important you add correct labels to objects that require them, such
as a Pod that will be referenced by a Service.

<pre><code class="lang-yaml">
metadata:
  name: nginx
  labels:
    app: demo-app
  annotations:
    created-by: ci-deploy

</code></pre>

<h4>Manifest spec fields</h4>

Your manifest <b>spec</b> will vary depending on the type of object you’re creating. You should follow the object type’s
documentation to check which fields are required and the effects that each one has. Some objects and CRDs won’t
use spec and will instead require you to add properties at the top level of the object adjacent to the metadata and

kind fields.

A few examples showing a basic spec for different Kubernetes built-in object types:

<b>Pod Spec</b>
<pre><code class="lang-yaml">
spec:
containers:
- name: nginx
image: nginx:latest
</code></pre>

<b>Service Spec</b>
<pre><code class="lang-yaml">
spec:
selector:
app: nginx
ports:
- port: 80
</code></pre>

<b> Deployment Spec</b>
<pre><code class="lang-yaml">
spec:
replicas: 3
selector:
matchLabels:
app: nginx
template:
metadata:
labels:
app: nginx
spec:
containers:
- name: nginx
image: nginx:latest
</code></pre>

Notice how the Deployment object’s spec includes another manifest within its template field. This defines the Pod
manifest that will be used to create the Pods required by the Deployment.


<h3>Writing a manifest for multiple objects in one file</h3>

Kubernetes objects are often mapped 1:1 with the manifest files that contain them. This is acceptable practice,
but it’s also possible to declare multiple objects within a single manifest file. To do this, you should use YAML’s <b>---</b>
sequence to split each object into its own section in the manifest:

<pre><code class="lang-yaml">
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    app:
      nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest

---

apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
    - port: 80
</code></pre>

Applying this manifest to your cluster will create both the Pod and Service objects.

<h3> Using multiple manifest files </h3>

When you’re using multiple files, you can bulk apply them to your cluster by passing a directory path to kubectl apply:
<pre><code class="lang-yaml">kubectl apply -f /path/to/manifests  </code></pre>

This will apply all the manifests in the directory. You can optionally recurse into subdirectories by setting
the <b>--recursive</b> or <b>-R</b> flag.


<b>Tipps</b>: <a href="https://spacelift.io/blog/kubernetes-manifest-file#kubernetes-manifest-best-practices">Here</a>


</pre></body></html></div>
</div>
</div>


</body></html>